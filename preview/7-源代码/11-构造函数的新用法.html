<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
	<script type="text/javascript">
		/*var Person = function(name) {
			this.name = name;
		};

		var p = new Person("放屁虫");*/

		// 构造函数的返回值问题：
		// 1 如果返回的是 基本类型的，此时，return语句会被忽略掉，
		// 		返回的还是：新创建出来的对象
		// 2 如果返回的是 引用类型，此时，会把return语句返回的对象直接返回
		// 		那么，此时，new 出来的对象，就被忽略掉了！

		/*var Person = function(name) {
			this.name = name;

			// 一下情况都会被忽略掉！
			// return 123;
			// return true;
			// return "true";
			// return;
			// return null;
			// return undefined;

			// 此时，直接返回 return 后面的对象，而new出来的对象被忽略！
			// return [999, 666];
			// return {age: 19};

			// 因为此时，Person是当作构造函数来使用的，所以，this
			// 就是指向了新创建的对象！
			return this;
		};

		var p = new Person("放屁虫");
		console.log(p);*/


		// 有两个公司：A公司 和 B公司
		// A公司 需要调用 B公司的接口
		// 此时，B公司就给A公司提供一个接口
		// 
		// 接口文档：
		// 
		// 这种方式，创建对象，会更加强烈！
		// var p = new 接口();
		// p.getData()
		// p.updateData()
		
		
		// 工厂模式创建对象
		// 寄生模式创建对象
		var Person = function(name) {
			var age = 19;

			return {
				retAge: age,
				name: "小明",
				height: 180
			};
		};

		// 寄生模式创建对象
		// 本来new Person 创建的是一个 Person类型的实现
		// 但是，Person构造函数中 有一个return 语句，返回了一个对象
		// 此时，会把return 返回的对象，直接返回！
		var p = new Person("放屁虫");


		// 工厂模式创建对象
		var p1 = Person("竹子");
		var p2 = Person("纸箱");
		console.log(p1);
		console.log(p2);

		// 工厂模式要比寄生模式效率高！
		// 对外开发的接口 使用 寄生模式
		// 自己内部使用，直接工厂模式就可以了！
		
		var Student = function(name, age) {
			this.name = name;
			this.age = age;
		};
		
		// 这是一个工厂函数，作用就是用来产生对象的！
		var stuFactory = function(name, age) {
			return new Student(name, age);
		};

		// 如果将来再使用 学生对象，只需要调用 stuFactory 就可以了！
		var stu1 = stuFactory("小明", 19);
		var stu2 = stuFactory("小红", 18);
	</script>
</body>
</html>