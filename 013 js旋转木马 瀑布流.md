# 13 JS 旋转木马 瀑布流

旋转木马 瀑布流 scroll家族

---

## 旋转木马

旋转木马效果的原理是把设定好位置、大小、透明度以及层级的数组赋值给对应的图片，当需要轮转的时候，交换数组的首尾排序，使得每一个图片li获得旁边一个的属性，并向之运动，形成了旋转木马的效果

1. 初始化布局之后，读取一次数组数据，让所有的图片li运动到当前数组指定的位置
2. 设置两侧按钮的显示/隐藏效果
3. 利用数组pop()方法把数组最后一个提取出来之后插入到第一个，让图片li按新的数组运动一次，这样就形成了向右轮转的效果
4. 同样的，shift()方法也是把第一个提取出来后插入到最后，形成的动画就是向左轮转的效果
5. 基本功能已经OK。
6. 【优化】快速点击会按钮会转的太快，需要限制转动的速度。由于缓动动画中，我们定义了一个fn函数的执行，执行的时间是当前运动到目的位置之后，所以根据这个特性，我们定义一个flag全局变量
7. 设定初始flag=true，当flag=true时，点击按钮之后立即把flag复制false，此时点击按钮就没有效果了
8. 按钮点击后的缓动动画里，我们加入一个实参函数，函数里我们给flag赋值true。实际效果就是当前动画播放完毕之后，flag=true，可以再次点击按钮
9. 优化的过程叫做函数节流阀，限制某个功能运行过快

## scroll家族

#### scroll家族可以获得页面卷去的高度和宽度
```
//scroll的兼容性写法, 获得对象属性top和left
function scroll() {
    return {
        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,
        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
    };
}
```

#### clientWidth clientHeight
- 和offsetWidth/offsetHeight的区别是不包含border的大小
```
//获得可视区域宽高的兼容性写法
function client() {
    return {
        "width":window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
        "height":window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
    };
}
```

#### onscroll方法

```
//当页面滚动时
window.onscroll = function() {}
```

## 瀑布流

**思路**: 让所有图片按照统一的宽度, 无缝的像流水一样排布. 

- 所有图片左浮动之后,会全部靠左,只要能靠的就会靠过去,只有第一排的图片正常, 此时再有的图片就顶着第一排继续排了, 所以我们要调整的就是从这张开始.
- 我们现在要把开始的图片, 放到第一列高度最低的图片下面, 放完之后, 算一下现在的高度, 接着放下一张到最低的高度, 后面的图片以此类推的, 全部放入
- 当然我们就只有一些图片, 要形成流水, 必须继续创建更多的图片, 然后创建的这些图片, 样式是和之前的图片一样, 同时继续根据排列的方式排列下去
- 创建的这些图片, 需要在我们滚动鼠标到下方就创建, 即大于了所有图片的最低的高度时就创建一批

1. 将创建的图片左浮动自动排布后, 获得第一排的个数, 方式是用页面的宽度除以单个图片的宽度, 向下取整后, 就是第一排的个数
2. 创建一个数组, 记录下这排图片的高度, `arr.push(pic.height)`
3. 创建一个方法, 获得这个数组里最低的高度的序号以及值
4. 利用for遍历除第一列之外的图片, 把图片放到数组里记录的最低高度的那一列下面, 设置图片的定位方式为绝对定位, 放到最低那一列下面的left值和这一列的值相同, top则刚好等于这一列的高度
5. 放入图片之后, 数组最低的这个值相应的增加, 增加的是放入的图片的高度
6. 这样再放下一张图片的时候, 重复这个过程, 再次放入, 以此类推的, 我们这些图片就全部自动排列好了
7. 下面要解决创建的图片的问题了, 我们先获得页面卷去的高度(scroll().top), 再获得浏览器的高度(client().height), 那么我们滚动的时候, 如果卷去的高度和浏览器高度的和大于了现有的图片列里最低的那个高度的时候, 这个时候就要开始创建新的图片列表了
8. 获得创建图片的资源(图片链接的地址, 放入到数组中), 利用遍历数组来创建元素(createElement), 创建的元素添加className, 加入内容(innerHTML),内容就是图片标签, 图片的资源地址, 就从数组里获得.
9. 把创建好的元素放到当前图片序列之后, 同时创建出来的序列继续依照之前图片排序的规则再次排序.
10. 大功告成, 瀑布流已经完工.

**简单优化** 因为范例插入的图片宽度相同, 那么如果放入多张图片宽度不一样的时候就需要处理, 处理方式是给图片img标签添加属性(setAttribute("width",宽度)), 这个宽度可以取第一张图片的宽度来设定(注意img标签外包的标签可能有边框/内边距, 设定宽度时计算清楚), 设定好宽度后, 后续的图片会自动的按比例缩放, 高度就变成自适应了. 当然不要忘了给创建出来的元素的img标签也加上这个属性



Tags： black_horse
